import { NextRequest, NextResponse } from "next/server"
import { getServerSession } from "next-auth"
import { prisma } from "@/lib/prisma"
import { authOptions, canAccessStore } from "@/lib/auth"
import { createBundleSchema, bundleQuerySchema } from "@/lib/validations"
import { cacheInvalidatePattern } from "@/lib/redis"

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const storeId = searchParams.get("storeId")
    
    if (!storeId) {
      return NextResponse.json({ error: "Store ID is required" }, { status: 400 })
    }

    // Check store access
    if (!(await canAccessStore(session.user.id, storeId))) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 })
    }

    // Validate query parameters
    const queryParams = bundleQuerySchema.parse({
      page: searchParams.get("page"),
      limit: searchParams.get("limit"),
      status: searchParams.get("status"),
      search: searchParams.get("search"),
      sortBy: searchParams.get("sortBy"),
      sortOrder: searchParams.get("sortOrder"),
      isAutoGenerated: searchParams.get("isAutoGenerated")
    })

    const { page, limit, status, search, sortBy, sortOrder, isAutoGenerated } = queryParams
    const skip = (page - 1) * limit

    // Build where clause
    const where: any = {
      storeId,
      ...(status && { status }),
      ...(isAutoGenerated !== undefined && { isAutoGenerated }),
      ...(search && {
        OR: [
          { title: { contains: search, mode: "insensitive" } },
          { description: { contains: search, mode: "insensitive" } }
        ]
      })
    }

    // Get bundles with pagination
    const [bundles, total] = await Promise.all([
      prisma.bundle.findMany({
        where,
        include: {
          items: {
            include: {
              product: {
                select: {
                  id: true,
                  title: true,
                  price: true,
                  images: {
                    orderBy: { position: "asc" },
                    take: 1
                  }
                }
              }
            },
            orderBy: { position: "asc" }
          },
          _count: {
            select: {
              orders: true,
              analytics: true
            }
          }
        },
        orderBy: { [sortBy]: sortOrder },
        skip,
        take: limit
      }),
      prisma.bundle.count({ where })
    ])

    // Calculate bundle metrics
    const bundlesWithMetrics = bundles.map(bundle => {
      const totalPrice = bundle.items.reduce((sum, item) => 
        sum + (item.product.price * item.quantity), 0)
      
      let bundlePrice = totalPrice
      if (bundle.pricingType === "PERCENTAGE_DISCOUNT" && bundle.discountValue) {
        bundlePrice = totalPrice * (1 - bundle.discountValue)
      } else if (bundle.pricingType === "FIXED_DISCOUNT" && bundle.discountValue) {
        bundlePrice = Math.max(0, totalPrice - bundle.discountValue)
      } else if (bundle.pricingType === "FIXED_PRICE" && bundle.fixedPrice) {
        bundlePrice = bundle.fixedPrice
      }

      return {
        ...bundle,
        metrics: {
          totalPrice,
          bundlePrice,
          savings: totalPrice - bundlePrice,
          savingsPercentage: totalPrice > 0 ? ((totalPrice - bundlePrice) / totalPrice) * 100 : 0,
          conversionRate: bundle.views > 0 ? (bundle.conversions / bundle.views) * 100 : 0
        }
      }
    })

    return NextResponse.json({
      bundles: bundlesWithMetrics,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    })

  } catch (error) {
    console.error("Error fetching bundles:", error)
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    const body = await request.json()
    const { storeId, ...bundleData } = body

    if (!storeId) {
      return NextResponse.json({ error: "Store ID is required" }, { status: 400 })
    }

    // Check store access
    if (!(await canAccessStore(session.user.id, storeId))) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 })
    }

    // Validate bundle data
    const validatedData = createBundleSchema.parse(bundleData)

    // Check if slug is unique within store
    const existingBundle = await prisma.bundle.findUnique({
      where: {
        storeId_slug: {
          storeId,
          slug: validatedData.slug
        }
      }
    })

    if (existingBundle) {
      return NextResponse.json(
        { error: "Bundle slug already exists" },
        { status: 409 }
      )
    }

    // Validate all products belong to the store
    const productIds = validatedData.items.map(item => item.productId)
    const products = await prisma.product.findMany({
      where: {
        id: { in: productIds },
        storeId,
        status: "ACTIVE"
      },
      select: { id: true, price: true, quantity: true, trackQuantity: true }
    })

    if (products.length !== productIds.length) {
      return NextResponse.json(
        { error: "Some products are invalid or not found" },
        { status: 400 }
      )
    }

    // Check inventory availability
    const inventoryIssues = validatedData.items.filter(item => {
      const product = products.find(p => p.id === item.productId)
      return product?.trackQuantity && 
             product.quantity < item.quantity
    })

    if (inventoryIssues.length > 0) {
      return NextResponse.json(
        { 
          error: "Insufficient inventory for some products",
          issues: inventoryIssues
        },
        { status: 400 }
      )
    }

    // Create bundle with items in a transaction
    const bundle = await prisma.$transaction(async (tx) => {
      const newBundle = await tx.bundle.create({
        data: {
          ...validatedData,
          storeId,
          startsAt: validatedData.startsAt ? new Date(validatedData.startsAt) : null,
          endsAt: validatedData.endsAt ? new Date(validatedData.endsAt) : null,
          items: {
            create: validatedData.items.map(item => ({
              productId: item.productId,
              quantity: item.quantity,
              required: item.required,
              position: item.position
            }))
          }
        },
        include: {
          items: {
            include: {
              product: {
                select: {
                  id: true,
                  title: true,
                  price: true,
                  images: {
                    orderBy: { position: "asc" },
                    take: 1
                  }
                }
              }
            }
          }
        }
      })

      // Create audit log
      await tx.auditLog.create({
        data: {
          storeId,
          userId: session.user.id,
          action: "CREATE_BUNDLE",
          resource: "BUNDLE",
          resourceId: newBundle.id,
          details: {
            title: newBundle.title,
            itemCount: newBundle.items.length
          }
        }
      })

      return newBundle
    })

    // Invalidate related caches
    await cacheInvalidatePattern(`recommendations:${storeId}:*`)

    return NextResponse.json(bundle, { status: 201 })

  } catch (error) {
    console.error("Error creating bundle:", error)
    
    if (error instanceof Error && error.name === "ZodError") {
      return NextResponse.json(
        { error: "Validation failed", details: error.message },
        { status: 400 }
      )
    }
    
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    )
  }
}